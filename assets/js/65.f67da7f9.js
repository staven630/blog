(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{800:function(t,a,s){"use strict";s.r(a);var e=s(66),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("  scope 属性用来进行 Bean 的作用域配置，可以配置 6 种类型的作用域：")]),t._v(" "),s("ul",[s("li",[t._v("singleton")]),t._v(" "),s("li",[t._v("prototype")]),t._v(" "),s("li",[t._v("request")]),t._v(" "),s("li",[t._v("session")]),t._v(" "),s("li",[t._v("application")]),t._v(" "),s("li",[t._v("websocket")])]),t._v(" "),s("h2",{attrs:{id:"singleton-单例作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#singleton-单例作用域"}},[t._v("#")]),t._v(" singleton（单例作用域）")]),t._v(" "),s("p",[t._v("  Spring IoC 容器只创建和维护一个该类型的 Bean 实例，并将这个实例存储到单例缓存中(singleton cache)中，针对该 Bean 的请求和引用，使用的都是用一个实例。从容器启动或者第一次调用实例化开始，只要容器没有退出或者销毁，该类型的单一实例就会一直存活。")]),t._v(" "),s("p",[t._v("  Spring 中同一个类可以进行多个单例 Bean 的配置，也就是一个类可以对应到多个不同的 id 对象。")]),t._v(" "),s("p",[t._v("  singleton 是最常用的作用域，也是默认的类型。也就是说，如果没有设置 Bean 的 scope 属性，则默认就是单例作用域。")]),t._v(" "),s("div",{staticClass:"language-xml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-xml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("bean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("singletonBean"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("class")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("com.staven.SingletonBeanService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("scope")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("singleton"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h2",{attrs:{id:"prototype-原型作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prototype-原型作用域"}},[t._v("#")]),t._v(" prototype（原型作用域）")]),t._v(" "),s("p",[t._v("  原型作用域的 Bean 在使用容器的 getBean()方法获取的时候，每次得到的都是一个新的对象。作为依赖对象注入到其他 Bean 的时候也会产生一个新的类对象。在代码层级来看，相当于每次使用都是使用 new 的操作符来层创建一个新的对象。")]),t._v(" "),s("p",[t._v("  容器不负责原型作用域 Bean 实例的完整生命周期，在初始化或装配完该 Bean 的类对象之后，容器就不再对该对象进行管理，而需要由客户端对该对象进行管理，特别是如果该对象占用了一些昂贵的资源，就需要手动释放。此外，对于 singleton 类型的 Bean，如果有配置对象的生命周期回调方法，则容器会根据配置进行调用，类似于 singleton Bean 使用后置处理器释放被 Bean 占用的资源，而 prototype Bean 即使配置了回调方法也不会调用。")]),t._v(" "),s("h2",{attrs:{id:"request-请求作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#request-请求作用域"}},[t._v("#")]),t._v(" request——请求作用域")]),t._v(" "),s("p",[t._v("  针对每次 HTTP 请求，Spring 都会创建一个 Bean 实例。")]),t._v(" "),s("h2",{attrs:{id:"session-会话作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#session-会话作用域"}},[t._v("#")]),t._v(" session——会话作用域")]),t._v(" "),s("p",[t._v("  适用于 HTTP Session，同一个 session 共享同一个 Bean 实例。")]),t._v(" "),s("h2",{attrs:{id:"application-应用作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#application-应用作用域"}},[t._v("#")]),t._v(" application——应用作用域")]),t._v(" "),s("p",[t._v("  整个 Web 应用，也就是在 ServletContext 生命周期中使用一个 Bean 实例。")]),t._v(" "),s("h2",{attrs:{id:"websocket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" websocket")]),t._v(" "),s("p",[t._v("  WebSocket 作用域的配置是在一个 WebSocket 连接的生命周期中共用一个 Bean 实例。")])])}),[],!1,null,null,null);a.default=n.exports}}]);